#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     ir_seeker,      sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     accelerometer,  sensorI2CHiTechnicAccel)
#pragma config(Motor,  mtr_S1_C1_1,     motorLEFT,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorRIGHT,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     motorARM1,     tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     motorARM2,     tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Servo,  srvo_S1_C3_1,    clawservo1,           tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    clawservo2,           tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#pragma DebuggerWindows ("joystickgame")
//--------------------------------------------------------------------------------------------------------------
/*
Change log
12-2-12 copied code from 12ydrive0.3c to teleop template - first working version, 6 rings in 2 min
12-2-12 added triple gear reduction to arm for more power
12-3-12 added deadband to joysticks and .78 (100/128) multiplier for more control
12-5-12 added radians to degrees formula for acceleration sensor
12-10-12 added led light for aiming.  tried some logrythmic controls. added motor encoder
12-11-12 added teleop template
12-12-12 added code for encoders. added servo positon for presets
12-13-12 added variables to make tuning the joystick easier
12-14-12 added encoder count variable and encoder target variables
12-15-12 programmed buttons to stop at multiple levels (single 36" arm)
12-16-12 adjusted servo angle and arm height (single 36" arm)
12-20-12 Worked on autonomus code and ideas to fit 18" size restriction (switchblade arm)
12-21-12 changed all fasteners to nylock nuts after kep nuts fell off repeatedly
12-22-12 practice - decided to add joint to middle of arm to fit into box
12-23-12 went to UNLV to study the engineering student robots and tour the lab
12-24-12 ran out of fasteners - everywhere closed for Christmas
12-26-12 went to cimmeron lab - built claw parts on shopbot
12-27-12 changed all gears to double hub design - looked for weak points in drive added chain tensioners
12-29-12 added double gear reduction to middle arm joint
12-30-12 added programming for middle arm joint and 2nd encoder
12-31-12 added more code for 2nd arm, stage 2 - allows movement without returning to zero every time
01-01-13 debugged code & deadband for motor hum - worked on joint re-design for front arm
01-02-13 changed front arm gear design for more strength.  shortened middle post for clearance
01-03-13 programmed buttons for preset levels - discovered problem for arm sequence on down travel
added home (position 6) high position (yellow button) might need multiple stages (due to tipping)

to do list
ir sensor
line followers
add override code for motors similar to drive code
make void drive
make void arm1
make void arm2
*/
// Drivers -----------------------------------------------------------------------------------------------------
#include "JoystickDriver.c"     		// Tells ROBOTC to include the driver file for the joystick.
#include "drivers/hitechnic-irseeker-v2.h"	// ir driver
//--------------------------------------------------------------------------------------------------------------
const int MIN_POS_CLAW	=	0;				// Minimum servo position 	#define MIN_POS			base 0
const int MAX_POS_CLAW	= 255;			// Maximum servo position 	#define MAX_POS			base 255
const int DELTA_POS     = 1;				// Step interval for servo 	#define DELTA_POS		base 1
const int DEAD_JOY 			= 10;				// Joystick Dead band														base 10
const int DEAD_ARM_1		= 10;				// ARM 1 Dead band															base 10
const int DEAD_ARM_2		= 10;				// ARM 2 Dead band															base 10
const int MAX_MOTOR_VAL = 100;			// max motor speed (0-100)											base 100
const float MAX_JOY_VAL = 127.0;		// max joystick value (-127 to 127)							base 127
const int SERVO_ANGLE_4 = 100;			// Servo angle for button 4 yellow 							base 100
const int SERVO_ANGLE_1 = 130;			// Servo angle for button 1 blue								base 130
const int SERVO_ANGLE_2 = 145;			// Servo angle for button 2 green								base 145
const int SERVO_ANGLE_3 = 30;				// Servo angle for button 3 red									base 30
const int SERVO_ANGLE_6 = 225;			// Servo angle for home position								base 225
const int POWER_1   		= 100;			// Arm Power level highest speed (0-100)
const int POWER_2   		= 100;			// Arm Power level low speed (0-100)
const int ENCODER_1_INIT= 0;				// Starting Arm 1 Position
const int	ENCODER_2_INIT= 0;				// Starting Arm 2 Position
const int ARM_1_COUNT_4 = 13000;		// arm 1 encoder for button 4 Top Rack yellow		base 13000
const int ARM_1_COUNT_1 = 4700;			// arm 1 encoder for button 1 Middle Rack blue	base 4700
const int ARM_1_COUNT_2 = 1000;			// arm 1 encoder for button 2 Low Rack green		base 1000
const int ARM_1_COUNT_3 = 8000;			// arm 1 encoder for button 3 Floor red					base 8000
const int ARM_1_COUNT_6 = 0;				// arm 1 encoder for button 3 home position			base 0
const int ARM_2_COUNT_4 = 4500;			// arm 2 encoder for button 4 Top Rack yellow		base 4500
const int ARM_2_COUNT_1 = 2250;			// arm 2 encoder for button 1 Middle Rack blue	base 2250
const int ARM_2_COUNT_2 = 1000;			// arm 2 encoder for button 2 Low Rack green		base 1000
const int ARM_2_COUNT_3	= 7000;			// arm 2 encoder for button 3 Floor red					base 7000
const int ARM_2_COUNT_6	= 0;				// arm 2 encoder for button 6 home position			base 0
int ARM_2_STATE					=	0;				// motor stage 2																base 0
int POS_CLAW 						= MAX_POS_CLAW;// set servo variable position
int	ENCODER_1_TRGT  		= 0;				//																							base 0
int ENCODER_2_TRGT  		= 0;				//																							base 0
// initalize robot---------------------------------------------------------------------------------------------
void initializeRobot()																// initialize servos and motors to starting positions.
{																											// void open bracket
	bFloatDuringInactiveMotorPWM 		= false; 							// the motors will NOT coast when power is not applied
	nMotorEncoder[motorARM1]				= ENCODER_1_INIT;			// reset the Motor Encoder of Motor ARM 1
	nMotorEncoder[motorARM2] 				= ENCODER_2_INIT;  		// reset the Motor Encoder of Motor ARM 2
	servo[clawservo1] 							= 180;								// set servo to zero
	servo[clawservo2] 							= 180;								// set servo to zero
	wait1Msec(500);																				// Pause to let servos move
	motor[motorLEFT] 								= 0;									// Turn Motor Off
	motor[motorRIGHT] 							= 0;									// Turn Motor Off
	return;
}																											// void close bracket
// Joystick log routine-----------------------------------------------------------------------------------------
int scaleForMotor(int joyValue)
{
	if(abs(joyValue) < DEAD_JOY)								//check for deadzone if in range use 0 to eliminate motor hum
	{
		return 0;
	}
	int direction = joyValue / abs(joyValue); 																// 1 or -1 to indicate direction
	float ratio = ((joyValue * joyValue) / (MAX_JOY_VAL * MAX_JOY_VAL));			// calculate float ratio
	int scaledVal = (ratio * MAX_MOTOR_VAL) * direction;											//calculate scaled value
	return scaledVal;
}
//--------------------------------------------------------------------------------------------------------------
task main()
{																																// Start Main Loop
	initializeRobot(); 																						// Get ready! see void initalizerobot() above
	waitForStart();   																						// wait for start of tele-op phase From FCS
	// Start the loop ----------------------------------------------------------------------------------------------
	while(true)
	{																															// Start While loop
		// Right and Left Joysticks-------------------------------------------------------------------------------------
		getJoystickSettings(joystick);  															// Update Buttons and Joysticks
		motor[motorLEFT]  = scaleForMotor(joystick.joy2_y1);
		motor[motorRIGHT] =-scaleForMotor(joystick.joy2_y2);
		// Buttons------------------------------------------------------------------------------------------------------
		if(joy1Btn (1)== 1)  		    																// If Joy1-Button (1 blue X) is pressed:
		{																													//1open bracket
			ENCODER_1_TRGT = ARM_1_COUNT_1 - nMotorEncoder[motorARM1];
			ENCODER_2_TRGT = ARM_2_COUNT_1 - nMotorEncoder[motorARM2];
			ARM_2_STATE = 1;																			// Trigger for Stage 2
			//---------
			if (ENCODER_1_TRGT > DEAD_ARM_1)
			{																											//2open bracket
				PlaySound(soundShortBlip);
				wait1Msec(500);
				nMotorEncoderTarget[motorARM1] = ENCODER_1_TRGT;			// set the  target for Motor Encoder of Motor ARM

				motor[motorARM1] = POWER_1;               						// motor ARM is run at high power level
				while(nMotorRunState[motorARM1] != runStateIdle)  		// while Motor ARM hasn't reached target yet:
				{																										//3open - wait for motor to catch up
					servo[clawservo1] = SERVO_ANGLE_1;									// move servo to new position
					servo[clawservo2] = SERVO_ANGLE_1;									// move servo to new position
					motor[motorLEFT]  = scaleForMotor(joystick.joy1_y1);// allow robot to drive while arm moves
					motor[motorRIGHT] = -scaleForMotor(joystick.joy1_y2);// allow robot to drive while arm moves
				}																										//3close
				ENCODER_1_TRGT = 0;
				motor[motorARM1] = 0;              									// stop motor and hold position
			}
			if (ENCODER_2_TRGT > DEAD_ARM_2)
			{
				nMotorEncoderTarget[motorARM2] = ENCODER_2_TRGT;			// set the  target for Motor Encoder of Motor ARM
				motor[motorARM2] = POWER_2;               						// motor ARM is run at high power level
				while(nMotorRunState[motorARM2] != runStateIdle)  		// while Motor ARM hasn't reached target yet:
				{																										// wait for motor to catch up
					motor[motorLEFT]  = scaleForMotor(joystick.joy1_y1);// allow robot to drive while arm moves
					motor[motorRIGHT] =-scaleForMotor(joystick.joy1_y2);// allow robot to drive while arm moves
				}
				servo[clawservo1] = SERVO_ANGLE_1;									// move servo to new position
				servo[clawservo2] = SERVO_ANGLE_1;									// move servo to new position
				ENCODER_2_TRGT = 0;
			}																											// 2close
			//---------
			if (ENCODER_2_TRGT <  -DEAD_ARM_2)
			{
				nMotorEncoderTarget[motorARM2] = ENCODER_2_TRGT;			// set the  target for Motor Encoder of Motor ARM
				motor[motorARM2] = -POWER_2;               						// motor ARM is run at high power level
				while(nMotorRunState[motorARM2] != runStateIdle)  		// while Motor ARM hasn't reached target yet:
				{																										// wait for motor to catch up
					//						servo[clawservo1] = SERVO_ANGLE_1;									// move servo to new position
					//						servo[clawservo2] = SERVO_ANGLE_1;									// move servo to new position
					motor[motorLEFT]  = scaleForMotor(joystick.joy1_y1);// allow robot to drive while arm moves
					motor[motorRIGHT] =-scaleForMotor(joystick.joy1_y2);// allow robot to drive while arm moves
				}
				servo[clawservo1] = SERVO_ANGLE_1;									// move servo to new position
				servo[clawservo2] = SERVO_ANGLE_1;									// move servo to new position
				ENCODER_2_TRGT = 0;
			}

			else if (ENCODER_1_TRGT <  -DEAD_ARM_1)
			{																											//4open
				nMotorEncoderTarget[motorARM1] = ENCODER_1_TRGT;			// set the  target for Motor Encoder of Motor ARM
				motor[motorARM1] = -POWER_1;               						// motor ARM is run at high power level
				while(nMotorRunState[motorARM1] != runStateIdle)  		// while Motor ARM hasn't reached target yet:
				{																										//5open - wait for motor to catch up
					servo[clawservo1] = SERVO_ANGLE_1;									// move servo to new position
					servo[clawservo2] = SERVO_ANGLE_1;									// move servo to new position
					motor[motorLEFT]  = scaleForMotor(joystick.joy1_y1);// allow robot to drive while arm moves
					motor[motorRIGHT] =-scaleForMotor(joystick.joy1_y2);// allow robot to drive while arm moves
				}																										//5close
				motor[motorARM1] = 0;              									// stop motor and hold position
				ENCODER_1_TRGT = 0;
			}																											//4close
			//---------

			motor[motorARM1] = 0;              									// stop motor and hold position
			motor[motorARM2] = 0;              									// stop motor and hold position
		} 																														//1close
		// Button 2 Stage 1----------------------------------------------------------------------------------------------
		else if(joy1Btn (2)== 1)																				// If Joy1-Button (2 green B) is pressed:
		{																													//1open bracket
			ENCODER_1_TRGT = ARM_1_COUNT_2 - nMotorEncoder[motorARM1];
			ENCODER_2_TRGT = ARM_2_COUNT_2 - nMotorEncoder[motorARM2];
			//---------
			if (ENCODER_1_TRGT > DEAD_ARM_1)
			{while (ENCODER_2_TRGT > DEAD_ARM_2)
				{
					nMotorEncoderTarget[motorARM1] = ENCODER_1_TRGT;			// set the  target for Motor Encoder of Motor ARM
					motor[motorARM1] = POWER_1;               						// motor ARM is run at high power level
					while(nMotorRunState[motorARM1] != runStateIdle)  		// while Motor ARM hasn't reached target yet:
					{																										// wait for motor to catch up
						servo[clawservo1] = SERVO_ANGLE_2;									// move servo to new position
						servo[clawservo2] = SERVO_ANGLE_2;									// move servo to new position
						motor[motorLEFT]  = scaleForMotor(joystick.joy1_y1);// allow robot to drive while arm moves
						motor[motorRIGHT] =-scaleForMotor(joystick.joy1_y2);// allow robot to drive while arm moves
					}

					nMotorEncoderTarget[motorARM2] = ENCODER_2_TRGT;			// set the  target for Motor Encoder of Motor ARM
					motor[motorARM2] = POWER_2;               						// motor ARM is run at high power level
					while(nMotorRunState[motorARM2] != runStateIdle)  		// while Motor ARM hasn't reached target yet:
					{																										// wait for motor to catch up
						servo[clawservo1] = SERVO_ANGLE_2;									// move servo to new position
						servo[clawservo2] = SERVO_ANGLE_2;									// move servo to new position
						motor[motorLEFT]  = scaleForMotor(joystick.joy1_y1);// allow robot to drive while arm moves
						motor[motorRIGHT] =-scaleForMotor(joystick.joy1_y2);// allow robot to drive while arm moves
					}
					ENCODER_1_TRGT = 0;
					ENCODER_2_TRGT = 0;
					motor[motorARM1] = 0;              									// stop motor and hold position
			}}
			//---------
			else if (ENCODER_2_TRGT <  -DEAD_ARM_2)
			{
				while  (ENCODER_1_TRGT <  -DEAD_ARM_1)
				{
					nMotorEncoderTarget[motorARM2] = ENCODER_2_TRGT;			// set the  target for Motor Encoder of Motor ARM
					motor[motorARM2] = -POWER_2;               						// motor ARM is run at high power level
					while(nMotorRunState[motorARM2] != runStateIdle)  		// while Motor ARM hasn't reached target yet:
					{																										// wait for motor to catch up
						servo[clawservo1] = SERVO_ANGLE_2;									// move servo to new position
						servo[clawservo2] = SERVO_ANGLE_2;									// move servo to new position
						motor[motorLEFT]  = scaleForMotor(joystick.joy1_y1);// allow robot to drive while arm moves
						motor[motorRIGHT] =-scaleForMotor(joystick.joy1_y2);// allow robot to drive while arm moves
					}
				}

				nMotorEncoderTarget[motorARM1] = ENCODER_1_TRGT;			// set the  target for Motor Encoder of Motor ARM
				motor[motorARM1] = -POWER_1;               						// motor ARM is run at high power level
				while(nMotorRunState[motorARM1] != runStateIdle)  		// while Motor ARM hasn't reached target yet:
				{																										//5open - wait for motor to catch up
					servo[clawservo1] = SERVO_ANGLE_2;									// move servo to new position
					servo[clawservo2] = SERVO_ANGLE_2;									// move servo to new position
					motor[motorLEFT]  = scaleForMotor(joystick.joy1_y1);// allow robot to drive while arm moves
					motor[motorRIGHT] =-scaleForMotor(joystick.joy1_y2);// allow robot to drive while arm moves
			}}
			//---------
			ENCODER_1_TRGT = 0;
			ENCODER_2_TRGT = 0;

			motor[motorARM1] = 0;              									// stop motor and hold position
			motor[motorARM2] = 0;              									// stop motor and hold position
		}
		//--------------------------------------------------------------------------------------------------------------
		else if(joy1Btn (3)== 1)																	// If Joy1-Button (3 red B) is pressed:
		{																													//1open bracket
			ENCODER_1_TRGT=ARM_1_COUNT_3-nMotorEncoder[motorARM1];
			ARM_2_STATE = 3;																			// Trigger for Stage 2
			//---------
			if (ENCODER_1_TRGT > DEAD_ARM_1)
			{																											//2open bracket
				nMotorEncoderTarget[motorARM1] = ENCODER_1_TRGT;			// set the  target for Motor Encoder of Motor ARM
				motor[motorARM1] = POWER_1;               						// motor ARM is run at high power level
				while(nMotorRunState[motorARM1] != runStateIdle)  		// while Motor ARM hasn't reached target yet:
				{																										//3open - wait for motor to catch up
					servo[clawservo1] = SERVO_ANGLE_3;									// move servo to new position
					servo[clawservo2] = SERVO_ANGLE_3;									// move servo to new position
					motor[motorLEFT]  = scaleForMotor(joystick.joy1_y1);// allow robot to drive while arm moves
					motor[motorRIGHT] =-scaleForMotor(joystick.joy1_y2);// allow robot to drive while arm moves
				}																										//3close
				ENCODER_1_TRGT = 0;
				motor[motorARM1] = 0;              									// stop motor and hold position
			}																											// 2close
			//---------
			else if (ENCODER_1_TRGT <  -DEAD_ARM_1)
			{																											//4open
				nMotorEncoderTarget[motorARM1] = ENCODER_1_TRGT;			// set the  target for Motor Encoder of Motor ARM
				motor[motorARM1] = -POWER_1;               						// motor ARM is run at high power level
				while(nMotorRunState[motorARM1] != runStateIdle)  		// while Motor ARM hasn't reached target yet:
				{																										//5open - wait for motor to catch up
					servo[clawservo1] = SERVO_ANGLE_3;									// move servo to new position
					servo[clawservo2] = SERVO_ANGLE_3;									// move servo to new position
					motor[motorLEFT]  = scaleForMotor(joystick.joy1_y1);// allow robot to drive while arm moves
					motor[motorRIGHT] =-scaleForMotor(joystick.joy1_y2);// allow robot to drive while arm moves
				}																										//5close
				motor[motorARM1] = 0;              									// stop motor and hold position
				ENCODER_1_TRGT = 0;
			}																											//4close
			//---------
			else if	(-DEAD_ARM_1 < ENCODER_1_TRGT < DEAD_ARM_1)
			{
				motor[motorARM1] = 0;              									// stop motor and hold position
			}
			//---------
			if (ARM_2_STATE == 3)      															// If Joy1-Button (1 blue X) is pressed:
			{
				ENCODER_2_TRGT = ARM_2_COUNT_3 - nMotorEncoder[motorARM2];
				if (ENCODER_2_TRGT > DEAD_ARM_2)
				{
					nMotorEncoderTarget[motorARM2] = ENCODER_2_TRGT;			// set the  target for Motor Encoder of Motor ARM
					motor[motorARM2] = POWER_2;               						// motor ARM is run at high power level
					//---------
					while(nMotorRunState[motorARM2] != runStateIdle)  		// while Motor ARM hasn't reached target yet:
					{																										// wait for motor to catch up
						servo[clawservo1] = SERVO_ANGLE_3;									// move servo to new position
						servo[clawservo2] = SERVO_ANGLE_3;									// move servo to new position
						motor[motorLEFT]  = scaleForMotor(joystick.joy1_y1);// allow robot to drive while arm moves
						motor[motorRIGHT] =-scaleForMotor(joystick.joy1_y2);// allow robot to drive while arm moves
					}
					ENCODER_2_TRGT = 0;
				}
				//---------
				else if (ENCODER_2_TRGT <  -DEAD_ARM_2)
				{
					nMotorEncoderTarget[motorARM2] = ENCODER_2_TRGT;			// set the  target for Motor Encoder of Motor ARM
					motor[motorARM2] = -POWER_2;               						// motor ARM is run at high power level
					while(nMotorRunState[motorARM2] != runStateIdle)  		// while Motor ARM hasn't reached target yet:
					{																										// wait for motor to catch up
						servo[clawservo1] = SERVO_ANGLE_3;									// move servo to new position
						servo[clawservo2] = SERVO_ANGLE_3;									// move servo to new position
						motor[motorLEFT]  = scaleForMotor(joystick.joy1_y1);// allow robot to drive while arm moves
						motor[motorRIGHT] =-scaleForMotor(joystick.joy1_y2);// allow robot to drive while arm moves
					}
					ENCODER_2_TRGT = 0;
				}
				//---------
				motor[motorARM2] = 0;              									// stop motor and hold position
				ARM_2_STATE = 0;
			}
		} 																													//1close
		//--------------------------------------------------------------------------------------------------------------
		else if(joy1Btn (4)== 1)																		// If Joy1-Button (4 yellow Y) is pressed:
		{																													//1open bracket
			ENCODER_1_TRGT=ARM_1_COUNT_4-nMotorEncoder[motorARM1];
			ARM_2_STATE = 4;																			// Trigger for Stage 2
			//---------
			if (ENCODER_1_TRGT > DEAD_ARM_1)
			{																											//2open bracket
				nMotorEncoderTarget[motorARM1] = ENCODER_1_TRGT;			// set the  target for Motor Encoder of Motor ARM
				motor[motorARM1] = POWER_1;               						// motor ARM is run at high power level
				while(nMotorRunState[motorARM1] != runStateIdle)  		// while Motor ARM hasn't reached target yet:
				{																										//3open - wait for motor to catch up
					//						servo[clawservo1] = SERVO_ANGLE_1;									// move servo to new position
					//						servo[clawservo2] = SERVO_ANGLE_1;									// move servo to new position
					motor[motorLEFT]  = scaleForMotor(joystick.joy1_y1);// allow robot to drive while arm moves
					motor[motorRIGHT] =-scaleForMotor(joystick.joy1_y2);// allow robot to drive while arm moves
				}																										//3close
				ENCODER_1_TRGT = 0;
				motor[motorARM1] = 0;              									// stop motor and hold position
			}																											// 2close
			//---------
			else if (ENCODER_1_TRGT <  -DEAD_ARM_1)
			{																											//4open
				nMotorEncoderTarget[motorARM1] = ENCODER_1_TRGT;			// set the  target for Motor Encoder of Motor ARM
				motor[motorARM1] = -POWER_1;               						// motor ARM is run at high power level
				while(nMotorRunState[motorARM1] != runStateIdle)  		// while Motor ARM hasn't reached target yet:
				{																										//5open - wait for motor to catch up
					servo[clawservo1] = SERVO_ANGLE_4;									// move servo to new position
					servo[clawservo2] = SERVO_ANGLE_4;									// move servo to new position
					motor[motorLEFT]  = scaleForMotor(joystick.joy1_y1);// allow robot to drive while arm moves
					motor[motorRIGHT] =-scaleForMotor(joystick.joy1_y2);// allow robot to drive while arm moves
				}																										//5close
				motor[motorARM1] = 0;              									// stop motor and hold position
				ENCODER_1_TRGT = 0;
			}																											//4close
			//---------
			else if	(-DEAD_ARM_1 < ENCODER_1_TRGT < DEAD_ARM_1)
			{
				motor[motorARM1] = 0;              									// stop motor and hold position
			}
			//---------
			if (ARM_2_STATE == 4)      															// If Joy1-Button (1 blue X) is pressed:
			{
				ENCODER_2_TRGT = ARM_2_COUNT_4 - nMotorEncoder[motorARM2];
				if (ENCODER_2_TRGT > DEAD_ARM_2)
				{
					nMotorEncoderTarget[motorARM2] = ENCODER_2_TRGT;			// set the  target for Motor Encoder of Motor ARM
					motor[motorARM2] = POWER_2;               						// motor ARM is run at high power level
					//---------
					while(nMotorRunState[motorARM2] != runStateIdle)  		// while Motor ARM hasn't reached target yet:
					{																										// wait for motor to catch up
						servo[clawservo1] = SERVO_ANGLE_4;									// move servo to new position
						servo[clawservo2] = SERVO_ANGLE_4;									// move servo to new position
						motor[motorLEFT]  = scaleForMotor(joystick.joy1_y1);// allow robot to drive while arm moves
						motor[motorRIGHT] =-scaleForMotor(joystick.joy1_y2);// allow robot to drive while arm moves
					}
					ENCODER_2_TRGT = 0;
				}
				//---------
				else if (ENCODER_2_TRGT <  -DEAD_ARM_2)
				{
					nMotorEncoderTarget[motorARM2] = ENCODER_2_TRGT;			// set the  target for Motor Encoder of Motor ARM
					motor[motorARM2] = -POWER_2;               						// motor ARM is run at high power level
					while(nMotorRunState[motorARM2] != runStateIdle)  		// while Motor ARM hasn't reached target yet:
					{																										// wait for motor to catch up
						servo[clawservo1] = SERVO_ANGLE_4;									// move servo to new position
						servo[clawservo2] = SERVO_ANGLE_4;									// move servo to new position
						motor[motorLEFT]  = scaleForMotor(joystick.joy1_y1);// allow robot to drive while arm moves
						motor[motorRIGHT] =-scaleForMotor(joystick.joy1_y2);// allow robot to drive while arm moves
					}
					ENCODER_2_TRGT = 0;
				}
				//---------
				motor[motorARM2] = 0;              									// stop motor and hold position
				ARM_2_STATE = 0;
			}
		} 																													//1close
		//--------------------------------------------------------------------------------------------------------------
		if(joy1Btn (5)== 1)      														// If Joy1-Left Button is pressed:
		{
			motor[motorARM1] = POWER_1;         								// Motor is run at high power level
			wait1Msec(10);																			// Wait for motor to move
		}
		//--------------------------------------------------------------------------------------------------------------
		else if(joy1Btn (6)== 1)      												// If Joy1- Right Button is pressed:
		{
			POS_CLAW -= DELTA_POS;													// move servo -1 step
			if (POS_CLAW < MIN_POS_CLAW)										// if servo is at minimum...
			{
				POS_CLAW = MIN_POS_CLAW;										// reset minimum position
			}
			servo[servo1] = POS_CLAW;												// move servo to new position
			servo[servo2] = POS_CLAW;												// move servo to new position
			wait1Msec(10);																	// wait for servo to move
		}

		//--------------------------------------------------------------------------------------------------------------
		else if(joy1Btn (7)== 1)      												// If Joy1- Left Trigger is pressed:
		{
			motor[motorARM1] = -POWER_1;   									// Motor is run at -high power level
			wait1Msec(10);																	// Wait for motor to start
		}
		//--------------------------------------------------------------------------------------------------------------
		else if(joy1Btn (8)== 1)      												// If Joy1- Right Trigger is pressed:
		{
			POS_CLAW += DELTA_POS;													// move servo 1 step
			if (POS_CLAW > MAX_POS_CLAW)										// if servo is at maximum...
			{
				POS_CLAW = MAX_POS_CLAW;										// reset maximum position
			}
			servo[servo1] = POS_CLAW;												// move servo to new position
			servo[servo2] = POS_CLAW;												// move servo to new position
			wait1Msec(10);																	// wait for servo to move
		}
		//--------------------------------------------------------------------------------------------------------------
		else if(joystick.joy1_TopHat == 0)    								// If 0 button on joy1's D-Pad (up) is pressed:
		{
			motor[motorARM2] = POWER_2;     								// Motor 2 power level.
			wait1Msec(10);																	// Wait for motor 2 to start
		}
		//--------------------------------------------------------------------------------------------------------------
		else if(joystick.joy1_TopHat == 1)    								// If 1 button on joy1's D-Pad (up right) is pressed:
		{
			motor[motorARM2] = POWER_2;     								// Motor 2 power level.
			wait1Msec(10);																	// Wait for motor 2 to start
		}
		//--------------------------------------------------------------------------------------------------------------
		else if(joystick.joy1_TopHat == 2)    								// If 2 button on joy1's D-Pad (right) is pressed:
		{
			PlaySound(soundShortBlip);  											// play the sound, 'soundshortblip'
		}
		//--------------------------------------------------------------------------------------------------------------
		else if(joystick.joy1_TopHat == 3)    								// If 3 button on joy1's D-Pad (rt dn) is pressed:
		{
			motor[motorARM2] = -POWER_2;         						// Motor 2 power level
			wait1Msec(10);																	// Wait for motor to start
		}
		//-------------------------------------------------------------------------------------------------------------
		else if(joystick.joy1_TopHat == 4)    								// If 4 button on joy1's D-Pad (down) is pressed:
		{
			motor[motorARM2] = -POWER_2;    									// Motor 2 power level
			wait1Msec(10);																	// Wait for motor to start
		}
		//-------------------------------------------------------------------------------------------------------------
		else if(joystick.joy1_TopHat == 5)    								// If 5 button on joy1's D-Pad (lt dn) is pressed:
		{
			motor[motorARM2] = -POWER_2;         						// Motor 2 power level
			wait1Msec(10);																	// Wait for motor to start
		}
		//------------------------------------------------------------------------------------------------------------
		else if(joystick.joy1_TopHat == 6)    								// If 6 button on joy1's D-Pad (left) is pressed:
		{																													//1open bracket
			ENCODER_1_TRGT = ARM_1_COUNT_6	-	nMotorEncoder[motorARM1];
			ENCODER_2_TRGT = ARM_2_COUNT_6 	- nMotorEncoder[motorARM2];

			while (ENCODER_2_TRGT <  -DEAD_ARM_2)
			{
				nMotorEncoderTarget[motorARM2] = ENCODER_2_TRGT;			// set the  target for Motor Encoder of Motor ARM
				motor[motorARM2] = -POWER_2;               						// motor ARM is run at high power level
				while(nMotorRunState[motorARM2] != runStateIdle)  		// while Motor ARM hasn't reached target yet:
				{																										// wait for motor to catch up

					motor[motorLEFT]  = scaleForMotor(joystick.joy1_y1);// allow robot to drive while arm moves
					motor[motorRIGHT] =-scaleForMotor(joystick.joy1_y2);// allow robot to drive while arm moves
				}
				ENCODER_2_TRGT = 0;
			}

			while (ENCODER_1_TRGT <  -DEAD_ARM_1)
			{																											//4open
				nMotorEncoderTarget[motorARM1] = ENCODER_1_TRGT;			// set the  target for Motor Encoder of Motor ARM
				motor[motorARM1] = -POWER_1;               						// motor ARM is run at high power level
				while(nMotorRunState[motorARM1] != runStateIdle)  		// while Motor ARM hasn't reached target yet:
				{																										//5open - wait for motor to catch up
					servo[clawservo1] = SERVO_ANGLE_6;									// move servo to new position
					servo[clawservo2] = SERVO_ANGLE_6;									// move servo to new position
					motor[motorLEFT]  = scaleForMotor(joystick.joy1_y1);// allow robot to drive while arm moves
					motor[motorRIGHT] =-scaleForMotor(joystick.joy1_y2);// allow robot to drive while arm moves
				}																										//5close
				ENCODER_1_TRGT = 0;
			}
			motor[motorARM1] = 0;              									// stop motor and hold position
			motor[motorARM2] = 0;              									// stop motor and hold position
		}
		//------------------------------------------------------------------------------------------------------------
		else if(joystick.joy1_TopHat == 7)    								// If 7 button on joy1's D-Pad (lt up) is pressed:
		{
			motor[motorARM2] = POWER_2;          					// Motor 2 power level
			wait1Msec(10);																	// Wait for motor to start
		}
		//------------------------------------------------------------------------------------------------------------
		else                            											// If Joy1-Buttons are NOT pressed:
		{
			motor[motorARM1] = 0;															// Turn Arm Motor 1 Off
			motor[motorARM2] = 0;															// Turn Arm Motor 2 Off
		}
		//------------------------------------------------------------------------------------------------------------
	}//2 End While Loop ----------------------------------------------------------------------------------------
}//1   End Task Main -----------------------------------------------------------------------------------------
